import React, { useEffect, useRef, useCallback } from 'react';
import Editor from '@monaco-editor/react';
import * as monaco from 'monaco-editor';
import { GhostTextManager } from './GhostTextManager';
import { useEditorStore, useEditorContent, useGhostText, useEditorLoading } from '../../store/editorStore';
import { FeedbackPanel } from './FeedbackPanel';

interface MainEditorProps {
  theme?: 'light' | 'dark' | 'vs-dark';
  onMount?: (editor: monaco.editor.IStandaloneCodeEditor) => void;
}

export const MainEditor: React.FC<MainEditorProps> = ({
  theme = 'dark',
  onMount,
}) => {
  const editorRef = useRef<monaco.editor.IStandaloneCodeEditor | null>(null);
  const ghostTextManagerRef = useRef<GhostTextManager | null>(null);
  const debounceTimerRef = useRef<number | null>(null);

  // Store hooks
  const content = useEditorContent();
  const ghostText = useGhostText();
  const { isLoading, isAISuggesting } = useEditorLoading();

  const {
    updateContent,
    updateCursorPosition,
    updateSelectionRange,
    acceptSuggestion,
    clearGhostText,
    generateAISuggestion,
    shouldTriggerAI,
    autoSave,
  } = useEditorStore();

  // Handle editor mount
  const handleEditorMount = useCallback(
    async (editor: monaco.editor.IStandaloneCodeEditor) => {
      editorRef.current = editor;
      ghostTextManagerRef.current = new GhostTextManager(editor);

      // Configure editor for immersive experience
      editor.updateOptions({
        fontSize: 16,
        fontFamily: '"SF Pro Text", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif',
        lineHeight: 1.8,
        wordWrap: 'on',
        wordWrapColumn: 80,
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        lineNumbers: 'off',
        rulers: [],
        renderLineHighlight: 'none',
        occurrencesHighlight: false,
        renderWhitespace: 'none',
        renderControlCharacters: false,
        folding: false,
        foldingHighlight: false,
        lineDecorationsWidth: 0,
        lineNumbersMinChars: 0,
        padding: { top: 20, bottom: 20 },
        scrollPredominantAxis: false,
        smoothScrolling: true,
        cursorBlinking: 'smooth',
        cursorStyle: 'line',
        cursorWidth: 2,
        bracketPairColorization: { enabled: false },
        guides: {
          indentation: false,
          bracketPairs: false,
          highlightActiveIndentation: false,
        },
      });

      // Set up keyboard shortcuts
      editor.addAction({
        id: 'accept-ghost-text',
        label: 'Accept Ghost Text',
        keybindings: [monaco.KeyCode.Tab],
        run: async () => {
          if (ghostTextManagerRef.current?.isVisible()) {
            await acceptSuggestion();
          }
        },
      });

      editor.addAction({
        id: 'dismiss-ghost-text',
        label: 'Dismiss Ghost Text',
        keybindings: [monaco.KeyCode.Escape],
        run: () => {
          clearGhostText();
        },
      });

      // Add content change listener with debouncing
      const disposable = editor.onDidChangeModelContent(() => {
        const newContent = editor.getValue();
        updateContent(newContent);

        // Debounce AI suggestion trigger
        if (debounceTimerRef.current) {
          clearTimeout(debounceTimerRef.current);
        }

        debounceTimerRef.current = setTimeout(() => {
          if (shouldTriggerAI()) {
            generateAISuggestion();
          }
        }, 2000);
      });

      // Add cursor position change listener
      editor.onDidChangeCursorPosition((e) => {
        const position = GhostTextManager.calculateCursorPosition(editor, e.position);
        updateCursorPosition(position);

        // Handle ghost text visibility based on cursor movement
        if (ghostTextManagerRef.current) {
          const shouldClear = ghostTextManagerRef.current.handleCursorPositionChange(position);
          if (shouldClear) {
            clearGhostText();
          }
        }
      });

      // Add selection change listener
      editor.onDidChangeCursorSelection((e) => {
        const selection = e.selection;
        const startOffset = editor.getModel()?.getOffsetAt(selection.getStartPosition()) || 0;
        const endOffset = editor.getModel()?.getOffsetAt(selection.getEndPosition()) || 0;

        updateSelectionRange({
          start: startOffset,
          end: endOffset,
        });

        // Handle ghost text visibility based on selection
        if (ghostTextManagerRef.current) {
          const shouldClear = ghostTextManagerRef.current.handleSelectionChange(selection);
          if (shouldClear) {
            clearGhostText();
          }
        }
      });

      // Auto-save on focus out
      editor.onDidBlurEditorText(() => {
        autoSave();
      });

      // Call external onMount callback if provided
      if (onMount) {
        onMount(editor);
      }

      // Setup auto-save interval
      const autoSaveInterval = setInterval(() => {
        autoSave();
      }, 30000); // Auto-save every 30 seconds

      // Cleanup function
      return () => {
        disposable.dispose();
        if (debounceTimerRef.current) {
          clearTimeout(debounceTimerRef.current);
        }
        clearInterval(autoSaveInterval);
      };
    },
    [updateContent, updateCursorPosition, updateSelectionRange, acceptSuggestion, clearGhostText, generateAISuggestion, shouldTriggerAI, autoSave, onMount]
  );

  // Sync ghost text with store
  useEffect(() => {
    if (!ghostTextManagerRef.current) return;

    if (ghostText?.isShowing) {
      ghostTextManagerRef.current.show(ghostText.suggestion, ghostText.position);
    } else {
      ghostTextManagerRef.current.clear();
    }
  }, [ghostText]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);

  // Loading overlay
  const renderLoadingOverlay = () => {
    if (!isLoading && !isAISuggesting) return null;

    return (
      <div className="absolute top-4 right-4 bg-black bg-opacity-75 text-white px-3 py-2 rounded-md text-sm flex items-center space-x-2 z-10">
        {isLoading && (
          <>
            <div className="w-3 h-3 border border-white border-t-transparent rounded-full animate-spin" />
            <span>Saving...</span>
          </>
        )}
        {isAISuggesting && (
          <>
            <div className="w-3 h-3 border border-white border-t-transparent rounded-full animate-spin" />
            <span>AI thinking...</span>
          </>
        )}
      </div>
    );
  };

  return (
    <div className="relative w-full h-full">
      {renderLoadingOverlay()}

      <div className="w-full h-full">
        <Editor
          height="100%"
          defaultLanguage="markdown" // Use markdown for better text editing experience
          value={content}
          theme={theme}
          onChange={(value) => {
            if (value !== undefined) {
              updateContent(value);
            }
          }}
          onMount={handleEditorMount}
          loading={
            <div className="flex items-center justify-center h-full w-full bg-editor-bg">
              <div className="flex flex-col items-center space-y-3">
                <div className="w-8 h-8 border-2 border-blue-400 border-t-transparent rounded-full animate-spin"></div>
                <div className="text-gray-400 text-sm">
                  Loading editor...
                </div>
              </div>
            </div>
          }
          options={{
            // Immersive editor options are set in onMount
            readOnly: false,
            automaticLayout: true,
          }}
        />
      </div>

      {/* Feedback Panel */}
      <FeedbackPanel
        isVisible={ghostText?.isShowing ?? false}
        position={ghostText?.position}
        onFeedback={async (feedback: string) => {
          // Handle feedback submission
          console.log('User feedback:', feedback);
          // Could trigger AI regeneration with feedback
          clearGhostText();
          // You could call generateAISuggestion() again here with feedback
        }}
      />
    </div>
  );
};

// CSS for immersive editor styling
export const editorCSS = `
/* Immersive editor styles */
.monaco-editor {
  background: transparent !important;
}

.monaco-editor .margin {
  background: transparent !important;
}

.monaco-editor .lines-content {
  background: transparent !important;
}

.monaco-editor .current-line {
  border: none !important;
  background: rgba(255, 255, 255, 0.02) !important;
}

.monaco-editor.vs-dark .current-line {
  background: rgba(255, 255, 255, 0.02) !important;
}

/* Custom scrollbar */
.monaco-editor .monaco-scrollable-element {
  scrollbar-width: thin;
  scrollbar-color: rgba(128, 128, 128, 0.3) transparent;
}

.monaco-editor .monaco-scrollable-element::-webkit-scrollbar {
  width: 8px;
}

.monaco-editor .monaco-scrollable-element::-webkit-scrollbar-track {
  background: transparent;
}

.monaco-editor .monaco-scrollable-element::-webkit-scrollbar-thumb {
  background-color: rgba(128, 128, 128, 0.3);
  border-radius: 4px;
}

.monaco-editor .monaco-scrollable-element::-webkit-scrollbar-thumb:hover {
  background-color: rgba(128, 128, 128, 0.5);
}

/* Loading overlay animation */
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.loading-pulse {
  animation: pulse 1.5s ease-in-out infinite;
}
`;